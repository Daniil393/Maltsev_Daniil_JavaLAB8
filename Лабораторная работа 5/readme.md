# Лабораторная работа 5. ИКНТ, Мальцев Даниил ИТ18 - группа LAB8.

Лабораторная работа представляет из себя:

## Класс Main - главный класс, который вызывает в себе классы и интерфейсы заданий 1 - 7

1.1) public class Fraction

1.2) public interface FractionalOperations

2.1) public class Cat

2.2) public interface Meowable

2.3) public class MeowUtils

3.1) public class Element

3.2) public class ElementList

3.3) public class ListProcessor

4.1) public class LoginGenerator

4.2) public class Student

4.3) public class StudentFileReader

Вспомогательный класс:
public class InputHelper - проверка ввода пользователя

---
Рассмотрим каждый класс индивидуально

## Класс Main

Класс Main в общей структуре состоит из цикла while, который прокручивает реализацию всех заданий, выбор самих заданий осуществляется с помощью конструкции switсh-case - пользователь выбирает какое задание он хочет просмотреть и в зависимости от его выбора реализуется соответствующий case

```java
System.out.println("\n=== Лабораторная работа 5 ===");
            System.out.println("1 - Шаблоны. Класс дробь");
            System.out.println("2 - Структурные шаблоны. Количество мяуканий");
            System.out.println("3 - Удаление элементов из списка");
            System.out.println("4 - Формирование и печать уникального логина для студента");
            System.out.println("5 - Сет. Работа с файлом");
            System.out.println("6 - Очередь наоборот");
            System.out.println("0 - Выход");
            System.out.print("Ваш выбор: ");
```

> Задание 1.1 (1 - Шаблоны. Класс дробь)
>
> В класс Дробь, добавить интерфейс на два метода: получение вещественного значения, установка 
> числителя и установка знаменателя.
> Сгенерировать такую версию дроби, которая будет кэшировать вычисление вещественного 
> значения.
> Если раннее в вашем варианте не было Дроби, то создайте сущность Дробь со следующими 
> особенностями:
> • Имеет числитель: целое число
> • Имеет знаменатель: целое число
> • Дробь может быть создана с указанием числителя и знаменателя 
> • Может вернуть строковое представление вида “числитель/знаменатель”
> • Необходимо корректно обрабатывать отрицательные значения. Учтите, что знаменатель не может 
> быть отрицательным. 
> • Переопределите метод сравнения объектов по состоянию таким образом, чтобы две дроби 
> считались одинаковыми тогда, когда у них одинаковые значения числителя и знаменателя.

В ходе выполнения данного задания был создан case 1, в котором вызывался класс Fraction, который реализует интерфейс FractionalOperations.

Case 1:

1. Пользователем вводятся числители и знаменатели двух дробей.
2. Создаются два объекта класса Fraction с проверкой корректности знаменателя.
3. Для каждой дроби выводится её строковое представление и вещественное значение.
4. Далее пользователю предоставляется меню для выполнения операций над дробями.
5. Реализована возможность изменения одной или обеих дробей путём вызова методов setNumerator() и setDenominator().
6. Реализовано сравнение дробей с использованием переопределённого метода equals().
7. При вводе некорректных данных (нулевой знаменатель) выбрасывается исключение и выводится сообщение об ошибке.
8. Пользователь может вернуться в главное меню после завершения работы с дробями.

### 1) Описание класса Fraction:

*Поля:*
   * private int numerator - числитель.
   * private int denominator - знаменатель.
   * private Double cachedValue - поле для кеширования значения дроби, по умолчанию значение равняется нулю.

*Конструктор:*
   * Fraction(int numerator, int denominator) - создаёт дробь с указанным числителем и знаменателем.
        - Если знаменатель равен 0, выбрасывается исключение IllegalArgumentException.
        - Если знаменатель отрицательный, знак переносится в числитель, чтобы знаменатель всегда был положительным.

*Методы:*
   * private void invalidateCache() - сбрасывает кеш вещественного значения.
   * public void setNumerator(int numerator) - задаёт новый числитель дроби и сбрасывает кеш вычисленного значения.
   * public void setDenominator(int denominator) - задаёт новый знаменатель дроби:
        - выбрасывает IllegalArgumentException, если знаменатель равен 0;
        - при отрицательном знаменателе переносит знак "-" в числитель;
        - сбрасывает кеш вычисленного значения.
   * public int getNumerator() - возвращает числитель дроби.
   * public int getDenominator() - возвращает знаменатель дроби.
   * public double getValue() - возвращает вещественное значение дроби. Использует кеш (cachedValue) для ускорения повторных вычислений.
   * public boolean equals(Object obj) - сравнивает дробь с другим объектом. Дроби считаются равными, если числитель и знаменатель совпадают.
   * Переопределенный toString() - формирует строковое представление.

### 2) Описание интерфейса FractionalOperations:

Интерфейс задаёт правило: любой класс, который его реализует, обязан предоставлять базовые операции для работы с дробями.

*Методы:*
   * double getValue() - возвращает вещественное значение дроби.
   * void setNumerator(int numerator) - задаёт числитель дроби.
   * void setDenominator(int denominator) - задаёт знаменатель дроби.

*Пример работы case 1*<br><br>

Ввод дробей:

<img width="380" height="472" alt="image" src="https://github.com/user-attachments/assets/66e5471a-2073-4046-8939-b6a6016591e0" /><br><br>

Сравнение дробей:

<img width="276" height="286" alt="image" src="https://github.com/user-attachments/assets/3d29ec94-dd16-4bab-b7d4-23773e248bcc" /><br><br>

Изменение обеих дробей и повторное сравнение:

<img width="315" height="507" alt="image" src="https://github.com/user-attachments/assets/0b3e74f7-ae9b-481d-85b6-19e024ba26a9" /> <img width="264" height="296" alt="image"
src="https://github.com/user-attachments/assets/d4dd3d47-8a21-4ad5-99d9-64c8dba792af" />

> Задание 2.1 (2 - Структурные шаблоны. Количество мяуканий)
>
> Необходимо создать:
> 1. сущность Кот, которая описывается следующим образом:
>    • Имеет Имя (строка)
>    • Для создания необходимо указать имя кота.
>    • Может быть приведен к текстовой форме вида: “кот: Имя”
>    • Может помяукать, что приводит к выводу на экран следующего текста: “Имя: мяу!”, 
> вызвать мяуканье можно без параметров.
> 2. интерфейс Мяуканье: разработайте метод, который принимает набор объектов способных 
> мяукать и вызывает мяуканье у каждого объекта. Мяукающие объекты должны иметь метод со 
> следующей сигнатурой: public void meow();
> 
> Далее необходимо таким образом передать кота в указанный метод, чтобы после окончания его работы 
> узнать сколько раз мяукал кот за время его работы.

В ходе выполнения данного задания был создан case 2, в котором использовались класс Cat, который реализует интерфейс Meowable и класс MeowUtils.

Case 2:

1. Создаётся объект Cat с заданной пользователем кличкой.
2. Пользователь через меню может воздействовать на объект: мяукнуть один раз, мяукнуть несколько раз, проверить количество мяуканий.
3. Методы meow() и meow(int n) выводят строку с именем кота и определенное количество «мяу», проверяя корректность ввода.
4. Утилиты MeowUtils.meowsCare() и declension() подсчитывают и корректно оформляют количество мяуканий.
5. Некорректный ввод обрабатывается с выводом информативного сообщения.

### 1) Описание класса Cat:

*Поля:*
   * private String name - кличка кота.
   * private int meowCount - подсчет количества мяуканий, по умолчанию равен нулю.

*Конструктор:*
   * public Cat(String name) - создает сущность кота с заданным именем.

*Методы:*
   * public void meow() - выводит в консоль строку вида "<имя>: мяу!". Так же после исползования увеличивает счетчик  meowCount на единицу.
   * public void meow(int n) - выводит n повторов "мяу", разделённых дефисами, например "<имя>: мяу-мяу-мяу!". Увеличивает  meowCount на n.
        - Если n <= 0, выводит предупреждение о невозможности мяукать такое количество раз.
   * public int getMeowCount() - выводит количество мяуканий.
   * Переопределенный toString() - формирует строковое представление.

### 2) Описание интерфейса Meowable:

Интерфейс задаёт правило: любой класс, который его реализует, обязан предоставлять возможность мяукать.

*Метод:*
   * void meow() - выполняет действие мяуканья, реализованное конкретным классом (например, выводит в консоль строку с именем кота и «мяу!»).

### 3) Описание класса MeowUtils:

*Метод:*
   * public static String declension(int n) - возвращает корректную форму слова «раз» для числа n (например, «раз» или «раза») для отображения количества мяуканий.

*Пример работы case 2*<br><br>

Создание кота и мяуканье - один раз:

<img width="370" height="557" alt="image" src="https://github.com/user-attachments/assets/ee83b0cc-1403-43b2-b65b-001c89e15596" /><br><br>

Кот мяукает 5 раз:

<img width="350" height="314" alt="image" src="https://github.com/user-attachments/assets/3e7089ff-982f-40a9-ba9f-77d6b32b8e18" /><br><br>

Проверка количества мяуканий:

<img width="367" height="421" alt="image" src="https://github.com/user-attachments/assets/b370c892-a9c5-40c1-8196-a406a478fcad" />

> Задание 3.1 (3 - Удаление элементов из списка)
>
> Составить программу, которая удаляет из списка L все элементы E, если такие есть.

В ходе выполнения данного задания был создан case 3, в котором использовались классы Element, ElementList и ListProcessor. 

Case 3:

1. Пользователь вводит список L заданного размера, содержащий целочисленные элементы.
2. Пользователь указывает количество элементов E, которые необходимо удалить из списка, и вводит их значения.
3. Для хранения списка используется объект ElementList, который проверяет корректность переданных данных.
4. Каждый элемент для удаления представлен объектом Element, инкапсулирующим значение удаляемого элемента.
5. Класс ListProcessor выполняет обработку списка - удаляет все вхождения элемента E из списка L с использованием метода removeElement().
6. Удаление выполняется последовательно для каждого значения из списка E.
7. После обработки выводится исходный список, список элементов для удаления и итоговый список L без указанных элементов.
8. Некорректный ввод (нулевой или отрицательный размер списка, отсутствие элементов для удаления) обрабатывается с выводом информативных сообщений об ошибках.

### 1) Описание класса Element:

*Поле:*
   * private Integer value - значение элемента списка.

*Конструктор:*
   * public Element(Integer value) - создаёт объект элемента с заданным значением.

*Методы:*
   * public Integer getValue() - возвращает значение элемента.
   * public void setValue(Integer value) - устанавливает новое значение элемента.
   * Переопределенный toString() - формирует строковое представление.

### 2) Описание класса ElementList:

*Поле:*
   * private List<Integer> list - список целых чисел, над которым выполняются операции.

*Конструктор:*
   * public ElementList(List<Integer> list) - создаёт объект списка:
        - если переданный список равен null, выбрасывается IllegalArgumentException;
        - выполняется копирование списка для защиты от внешних изменений.

*Методы:*
   * public List<Integer> getList() - возвращает список элементов.
   * Переопределенный toString() - формирует строковое представление.

### 3) Описание класса ListProcessor:

*Поля:*
   * private ElementList elementList - объект, содержащий обрабатываемый список.
   * private Element element - элемент, значение которого требуется удалить из списка.

*Конструктор:*
   * public ListProcessor(ElementList elementList, Element element) - создаёт обработчик списка:
        - если elementList или element равны null, выбрасывается IllegalArgumentException.

*Методы:*
   * public void removeElement() - удаляет все вхождения значения элемента E из списка L, используя предикат removeIf.
   * Переопределенный toString() - формирует строковое представление.

*Пример работы case 3*<br><br>

<img width="455" height="358" alt="image" src="https://github.com/user-attachments/assets/0c5cbbc8-be8b-4d09-adf6-9a10338b2aeb" />

> Задание 4.1 (4 - Формирование и печать уникального логина для студента)
>
> На вход программы подаются фамилии и имена учеников. Известно, что общее количество 
> учеников не превосходит 100. В первой строке вводится количество учеников, принимавших 
> участие в соревнованиях, N. Далее следуют N строк, имеющих следующий формат:
> <Фамилия><Имя>
> 
> Здесь <Фамилия> – строка, состоящая не более чем из 20 символов; <Имя>– строка, состоящая не 
> более чем из 15 символов. При этом <Фамилия> и <Имя> разделены одним пробелом. Примеры 
> входных строк:
> 
> *Иванова Мария*
> 
> *Петров Сергей*
> 
> Требуется написать программу, которая формирует и печатает уникальный логин для каждого 
> ученика по следующему правилу: если фамилия встречается первый раз, то логин – это данная 
> фамилия, если фамилия встречается второй раз, то логин – это фамилия, в конец которой 
> приписывается число 2 и т.д. Например, для входной последовательности:
> 
> *Иванова Мария*
> 
> *Петров Сергей*
> 
> *Бойцова Екатерина*
> 
> *Петров Иван*
> 
> *Иванова Наташа*
> 
> будут сформированы следующие логины:
> 
> *Иванова*
> 
> *Петров*
> 
> *Бойцова*
> 
> *Петров2*
> 
> *Иванова2*

В ходе выполнения данного задания был создан case 4, в котором использовались классы LoginGenerator, Student и StudentFileReader.

Case 4:

1. Пользователь указывает путь к файлу, содержащему список студентов.
2. Файл обрабатывается с помощью класса StudentFileReader, который:
   * считывает первую строку и интерпретирует её как количество студентов;
   * проверяет корректность значения (от 0 до 100);
   * считывает последующие строки формата «Фамилия Имя»;
   * при некорректных данных выбрасывает информативные исключения.
3. Для каждого студента создаётся объект класса Student, инкапсулирующий имя и фамилию.
4. Класс LoginGenerator формирует уникальные логины на основе фамилий студентов:
   * если фамилия встречается впервые, логин совпадает с фамилией;
   * при повторении фамилии к логину добавляется порядковый номер;
   * используется внутренний словарь для подсчёта количества одинаковых фамилий.
5. После успешного чтения данных выводится список считанных студентов и соответствующие им сгенерированные логины.
6. Все ошибки ввода-вывода и нарушения формата данных обрабатываются с выводом понятного сообщения пользователю.

### 1) Описание класса LoginGenerator:

*Поле:*
   * private Map<String, Integer> LastNameCount = new HashMap<>() - словарь для хранения количества уже сгенерированных логинов по каждой фамилии.

*Методы:*
   * public String generateLogin(Student student) - формирует логин для студента:
        - если фамилия встречается впервые, логин совпадает с фамилией;
        - при повторении фамилии к логину добавляется порядковый номер;
        - счётчик фамилий сохраняется внутри объекта.
   * Переопределенный toString() - формирует строковое представление.

### 2) Описание класса Student:

*Поля:*
   * private String firstName - имя студента.
   * private String lastName - фамилия студента.

*Конструктор:*
   * public Student(String firstName, String lastName) - создаёт объект студента с заданными именем и фамилией.

*Методы:*
   * public String getFirstName() - возвращает имя студента.
   * public String getLastName() - возвращает фамилию студента.
   * Переопределенный toString() - формирует строковое представление.

### 3) Описание класса StudentFileReader:

*Поле:*
   * private String filePath - путь к файлу со списком студентов.

*Конструктор:*
   * public StudentFileReader(String filePath) - создаёт объект для чтения студентов из указанного файла.

*Методы:*
   * public List<Student> readStudents() - считывает список студентов из файла:
        - проверяет корректность первой строки (количество студентов);
        - считывает данные студентов в формате «Фамилия Имя»;
        - при ошибках формата или чтения выбрасывает информативные исключения.
   * Переопределенный toString() - формирует строковое представление.

*Пример работы case 4*<br><br>

<img width="954" height="761" alt="image" src="https://github.com/user-attachments/assets/9566426f-96a1-448f-afe1-c1a9c00d76db" />

> Задание 5.1 (5 - Сет. Работа с файлом)
>
> Файл содержит текст на русском языке. Напечатать в алфавитном порядке все звонкие 
> согласные буквы, которые входят хотя бы в одно слово.

В ходе выполнения данного задания был создан case 5, в котором использовался класс VoicedConsonantsFromFile.

Case 5:

1. Пользователь вводит путь к текстовому файлу.
2. Файл обрабатывается с помощью отдельного класса VoicedConsonantsFromFile, отвечающего за анализ содержимого файла.
3. В процессе чтения файла выполняется посимвольная обработка текста:
   * каждый символ приводится к нижнему регистру;
   * проверяется, является ли символ буквой русского алфавита;
   * выполняется проверка принадлежности символа к множеству звонких согласных букв.
4. Все найденные звонкие согласные буквы добавляются в объект типа Set, что гарантирует отсутствие повторяющихся символов.
5. Для автоматической сортировки букв по алфавиту используется структура данных TreeSet.
6. После завершения обработки файла пользователю выводится список всех звонких согласных букв, которые встречаются хотя бы в одном слове текста, в алфавитном порядке.
7. Ошибки чтения файла и некорректный ввод обрабатываются с выводом информативных сообщений.

### 1) Описание класса VoicedConsonantsFromFile:

*Поле:*
   * private static final Set<Character> voiced - хранит множество звонких согласных букв русского алфавита.

*Методы:*
   * public static Set<Character> processFile(String filePath) - выполняет обработку файла:
                 - открывает файл по указанному пути;
                 - выполняет посимвольное чтение содержимого;
                 - приводит символы к нижнему регистру;
                 - проверяет, является ли символ русской буквой;
                 - определяет, относится ли символ к звонким согласным;
                 - добавляет найденные буквы в множество TreeSet, обеспечивающее уникальность и сортировку;
                 - при ошибках чтения файла выбрасывает исключение с информативным сообщением.
   * private static boolean isRussianLetter(char c) - вспомогательный метод для проверки принадлежности символа к русскому алфавиту.

*Пример работы case 5*<br><br>

<img width="757" height="91" alt="image" src="https://github.com/user-attachments/assets/c1e8b1d3-df2c-46fc-86cb-ae047041ca8c" />













