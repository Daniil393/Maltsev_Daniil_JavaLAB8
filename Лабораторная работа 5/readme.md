# Лабораторная работа 5. ИКНТ, Мальцев Даниил ИТ18 - группа LAB8.

Лабораторная работа представляет из себя:

## Класс Main - главный класс, который вызывает в себе классы и интерфейсы заданий 1 - 7

1.1) public class Fraction

1.2) public interface FractionalOperations

2.1) public class Cat

2.2) public interface Meowable

2.3) public class MeowUtils

3.1) public class Element

3.2) public class ElementList

3.3) public class ListProcessor

4.1) public class LoginGenerator

4.2) public class Student

4.3) public class StudentFileReader

Вспомогательный класс:
public class InputHelper - проверка ввода пользователя

---
Рассмотрим каждый класс индивидуально

## Класс Main

Класс Main в общей структуре состоит из цикла while, который прокручивает реализацию всех заданий, выбор самих заданий осуществляется с помощью конструкции switсh-case - пользователь выбирает какое задание он хочет просмотреть и в зависимости от его выбора реализуется соответствующий case

```java
System.out.println("\n=== Лабораторная работа 5 ===");
            System.out.println("1 - Шаблоны. Класс дробь");
            System.out.println("2 - Структурные шаблоны. Количество мяуканий");
            System.out.println("3 - Удаление элементов из списка");
            System.out.println("4 - Формирование и печать уникального логина для студента");
            System.out.println("5 - Сет. Работа с файлом");
            System.out.println("6 - Очередь наоборот");
            System.out.println("0 - Выход");
            System.out.print("Ваш выбор: ");
```

> Задание 1.1 (1 - Шаблоны. Класс дробь)
>
> В класс Дробь, добавить интерфейс на два метода: получение вещественного значения, установка 
> числителя и установка знаменателя.
> Сгенерировать такую версию дроби, которая будет кэшировать вычисление вещественного 
> значения.
> Если раннее в вашем варианте не было Дроби, то создайте сущность Дробь со следующими 
> особенностями:
> • Имеет числитель: целое число
> • Имеет знаменатель: целое число
> • Дробь может быть создана с указанием числителя и знаменателя 
> • Может вернуть строковое представление вида “числитель/знаменатель”
> • Необходимо корректно обрабатывать отрицательные значения. Учтите, что знаменатель не может 
> быть отрицательным. 
> • Переопределите метод сравнения объектов по состоянию таким образом, чтобы две дроби 
> считались одинаковыми тогда, когда у них одинаковые значения числителя и знаменателя.

В ходе выполнения данного задания был создан case 1, в котором вызывался класс Fraction, который реализует интерфейс FractionalOperations.

Case 1:

1. Пользователем вводятся числители и знаменатели двух дробей.
2. Создаются два объекта класса Fraction с проверкой корректности знаменателя.
3. Для каждой дроби выводится её строковое представление и вещественное значение.
4. Далее пользователю предоставляется меню для выполнения операций над дробями.
5. Реализована возможность изменения одной или обеих дробей путём вызова методов setNumerator() и setDenominator().
6. Реализовано сравнение дробей с использованием переопределённого метода equals().
7. При вводе некорректных данных (нулевой знаменатель) выбрасывается исключение и выводится сообщение об ошибке.
8. Пользователь может вернуться в главное меню после завершения работы с дробями.

### 1) Описание класса Fraction:

*Поля:*
   * private int numerator - числитель.
   * private int denominator - знаменатель.
   * private Double cachedValue - поле для кеширования значения дроби, по умолчанию значение равняется нулю.

*Конструктор:*
   * Fraction(int numerator, int denominator) - создаёт дробь с указанным числителем и знаменателем.
        - Если знаменатель равен 0, выбрасывается исключение IllegalArgumentException.
        - Если знаменатель отрицательный, знак переносится в числитель, чтобы знаменатель всегда был положительным.

*Методы:*
   * private void invalidateCache() - сбрасывает кеш вещественного значения.
   * public void setNumerator(int numerator) - задаёт новый числитель дроби и сбрасывает кеш вычисленного значения.
   * public void setDenominator(int denominator) - задаёт новый знаменатель дроби:
        - выбрасывает IllegalArgumentException, если знаменатель равен 0;
        - при отрицательном знаменателе переносит знак "-" в числитель;
        - сбрасывает кеш вычисленного значения.
   * public int getNumerator() - возвращает числитель дроби.
   * public int getDenominator() - возвращает знаменатель дроби.
   * public double getValue() - возвращает вещественное значение дроби. Использует кеш (cachedValue) для ускорения повторных вычислений.
   * public boolean equals(Object obj) - сравнивает дробь с другим объектом. Дроби считаются равными, если числитель и знаменатель совпадают.
   * Переопределенный toString() - формирует строковое представление.

### 2) Описание интерфейса FractionalOperations:

Интерфейс задаёт правило: любой класс, который его реализует, обязан предоставлять базовые операции для работы с дробями.

*Методы:*
   * double getValue() - возвращает вещественное значение дроби.
   * void setNumerator(int numerator) - задаёт числитель дроби.
   * void setDenominator(int denominator) - задаёт знаменатель дроби.

*Пример работы case 1*<br><br>

Ввод дробей:

<img width="380" height="472" alt="image" src="https://github.com/user-attachments/assets/66e5471a-2073-4046-8939-b6a6016591e0" /><br><br>

Сравнение дробей:

<img width="276" height="286" alt="image" src="https://github.com/user-attachments/assets/3d29ec94-dd16-4bab-b7d4-23773e248bcc" /><br><br>

Изменение обеих дробей и повторное сравнение:

<img width="315" height="507" alt="image" src="https://github.com/user-attachments/assets/0b3e74f7-ae9b-481d-85b6-19e024ba26a9" /> <img width="264" height="296" alt="image"
src="https://github.com/user-attachments/assets/d4dd3d47-8a21-4ad5-99d9-64c8dba792af" />

> Задание 2.1 (2 - Структурные шаблоны. Количество мяуканий)
>
> Необходимо создать:
> 1. сущность Кот, которая описывается следующим образом:
>    • Имеет Имя (строка)
>    • Для создания необходимо указать имя кота.
>    • Может быть приведен к текстовой форме вида: “кот: Имя”
>    • Может помяукать, что приводит к выводу на экран следующего текста: “Имя: мяу!”, 
> вызвать мяуканье можно без параметров.
> 2. интерфейс Мяуканье: разработайте метод, который принимает набор объектов способных 
> мяукать и вызывает мяуканье у каждого объекта. Мяукающие объекты должны иметь метод со 
> следующей сигнатурой: public void meow();
> 
> Далее необходимо таким образом передать кота в указанный метод, чтобы после окончания его работы 
> узнать сколько раз мяукал кот за время его работы.

В ходе выполнения данного задания был создан case 2, в котором использовались класс Cat, который реализует интерфейс Meowable и класс MeowUtils.

Case 2:

1. Создаётся объект Cat с заданной пользователем кличкой.
2. Пользователь через меню может воздействовать на объект: мяукнуть один раз, мяукнуть несколько раз, проверить количество мяуканий.
3. Методы meow() и meow(int n) выводят строку с именем кота и определенное количество «мяу», проверяя корректность ввода.
4. Утилиты MeowUtils.meowsCare() и declension() подсчитывают и корректно оформляют количество мяуканий.
5. Некорректный ввод обрабатывается с выводом информативного сообщения.

### 1) Описание класса Cat:

*Поля:*
   * private String name - кличка кота.
   * private int meowCount - подсчет количества мяуканий, по умолчанию равен нулю.

*Конструктор:*
   * public Cat(String name) - создает сущность кота с заданным именем.

*Методы:*
   * public void meow() - выводит в консоль строку вида "<имя>: мяу!". Так же после исползования увеличивает счетчик  meowCount на единицу.
   * public void meow(int n) - выводит n повторов "мяу", разделённых дефисами, например "<имя>: мяу-мяу-мяу!". Увеличивает  meowCount на n.
        - Если n <= 0, выводит предупреждение о невозможности мяукать такое количество раз.
   * public int getMeowCount() - выводит количество мяуканий.
   * Переопределенный toString() - формирует строковое представление.

### 2) Описание интерфейса Meowable:

Интерфейс задаёт правило: любой класс, который его реализует, обязан предоставлять возможность мяукать.

*Метод:*
   * void meow() - выполняет действие мяуканья, реализованное конкретным классом (например, выводит в консоль строку с именем кота и «мяу!»).

### 3) Описание класса MeowUtils:

*Метод:*
   * public static String declension(int n) - возвращает корректную форму слова «раз» для числа n (например, «раз» или «раза») для отображения количества мяуканий.

*Пример работы case 2*<br><br>

Создание кота и мяуканье - один раз:

<img width="370" height="557" alt="image" src="https://github.com/user-attachments/assets/ee83b0cc-1403-43b2-b65b-001c89e15596" /><br><br>

Кот мяукает 5 раз:

<img width="350" height="314" alt="image" src="https://github.com/user-attachments/assets/3e7089ff-982f-40a9-ba9f-77d6b32b8e18" /><br><br>

Проверка количества мяуканий:

<img width="367" height="421" alt="image" src="https://github.com/user-attachments/assets/b370c892-a9c5-40c1-8196-a406a478fcad" />

> Задание 3.1 (3 - Удаление элементов из списка)
>
> Составить программу, которая удаляет из списка L все элементы E, если такие есть.

В ходе выполнения данного задания был создан case 3, в котором использовались классы Element, ElementList и ListProcessor. 

Case 3:

1. Пользователь вводит список L заданного размера, содержащий целочисленные элементы.
2. Пользователь указывает количество элементов E, которые необходимо удалить из списка, и вводит их значения.
3. Для хранения списка используется объект ElementList, который проверяет корректность переданных данных.
4. Каждый элемент для удаления представлен объектом Element, инкапсулирующим значение удаляемого элемента.
5. Класс ListProcessor выполняет обработку списка - удаляет все вхождения элемента E из списка L с использованием метода removeElement().
6. Удаление выполняется последовательно для каждого значения из списка E.
7. После обработки выводится исходный список, список элементов для удаления и итоговый список L без указанных элементов.
8. Некорректный ввод (нулевой или отрицательный размер списка, отсутствие элементов для удаления) обрабатывается с выводом информативных сообщений об ошибках.

### 1) Описание класса Element:

*Поле:*
   * private Integer value - значение элемента списка.

*Конструктор:*
   * public Element(Integer value) - создаёт объект элемента с заданным значением.

*Методы:*
   * public Integer getValue() - возвращает значение элемента.
   * public void setValue(Integer value) - устанавливает новое значение элемента.
   * Переопределенный toString() - формирует строковое представление.

### 2) Описание класса ElementList:

*Поле:*
   * private List<Integer> list - список целых чисел, над которым выполняются операции.

*Конструктор:*
   * public ElementList(List<Integer> list) - создаёт объект списка:
        - если переданный список равен null, выбрасывается IllegalArgumentException;
        - выполняется копирование списка для защиты от внешних изменений.

*Методы:*
   * public List<Integer> getList() - возвращает список элементов.
   * Переопределенный toString() - формирует строковое представление.

### 3) Описание класса ListProcessor:

*Поля:*
   * private ElementList elementList - объект, содержащий обрабатываемый список.
   * private Element element - элемент, значение которого требуется удалить из списка.

*Конструктор:*
   * public ListProcessor(ElementList elementList, Element element) - создаёт обработчик списка:
        - если elementList или element равны null, выбрасывается IllegalArgumentException.

*Методы:*
   * public void removeElement() - удаляет все вхождения значения элемента E из списка L, используя предикат removeIf.
   * Переопределенный toString() - формирует строковое представление.

*Пример работы case 3*<br><br>

<img width="455" height="358" alt="image" src="https://github.com/user-attachments/assets/0c5cbbc8-be8b-4d09-adf6-9a10338b2aeb" />
