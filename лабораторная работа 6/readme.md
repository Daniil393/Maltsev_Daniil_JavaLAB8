# Лабораторная работа 6. ИКНТ, Мальцев Даниил ИТ18 – группа LAB8

Лабораторная работа представляет из себя:

# Класс Main - главный класс, который вызывает в себе классы заданий 1 - 8.

# Классы и аннотации к заданиям 1 - 8:

1) **Invoke**
   - @interface Invoke
   - class InvokeProcessor
   - class TestClass

2) **Default**
   - @interface Default
   - class DefaultProcessor
   - class TestClass2

3) **ToString**
   - enum Mode
   - @interface ToString
   - class ToStringProcessor
   - class Person

4) **Validate**
   - @interface Validate
   - class ValidateProcessor
   - class TestClass3

5) **Two**
   - @interface Two
   - class TwoProcessor
   - class TestClass4

6) **Cache**
   - @interface Cache
   - class CacheProcessor
   - class TestClass5
   - class TestClass6
   
&nbsp;

Рассмотрим каждый класс и аннотацию индивидуально

# Класс Main
Класс Main демонстрирует работу всех разработанных классов, выполняя требования заданий. Основная роль класса - создать объекты различных типов, вызвать их методы и визуально показать пользователю результаты работы.

Программа последовательно демонстрирует решения задач: функциональность пистолета, автомата, пистолета, который наследует класс Weapon; создание имен, телефонного справочника, стрелков; сравнение точек; возведение
чисел в степень.

&nbsp;

> Задание 1 – (аннотация @Invoke)

Разработайте аннотацию @Invoke, со следующими характеристиками:
• Целью может быть только МЕТОД
• Доступна во время исполнения программы
• Не имеет свойств
Создайте класс, содержащий несколько методов, и проаннотируйте хотя бы один из них 
аннотацией @Invoke.
Реализуйте обработчик (через Reflection API), который находит методы, отмеченные 
аннотацией @Invoke, и вызывает их автоматически.
___

В ходе выполнения данного задания были разработаны классы InvokeProcessor и TestClass, аннотация Invoke.

### Класс InvokeProcessor
В класс входит один метод

*Метод*:
public static void process(Object obj):
  - Получает класс переданного объекта.
  - Находит все объявленные методы этого класса.
  - Проверяет наличие аннотации @Invoke.
  - Делает такие методы доступными (в том числе private).
  - Вызывает их с помощью method.invoke().

### Класс TestClass - это тестовый класс для демонстрации работы аннотации @Invoke и класса InvokeProcessor.
В классе объявлены три метода:
   - methodOne() — помечен аннотацией @Invoke
   - methodTwo() — обычный метод (без аннотации)
   - methodThree() — также помечен аннотацией @Invoke

При передаче объекта TestClass в InvokeProcessor.process() будут автоматически вызваны только методы methodOne() и methodThree(), так как они содержат аннотацию @Invoke.

### Аннотация Invoke
@Invoke — это пользовательская аннотация, предназначенная для пометки методов, которые должны быть автоматически вызваны во время выполнения программы.

Описание:
   - @Target(ElementType.METHOD)\
   Указывает, что аннотацию можно применять только к методам.

   - @Retention(RetentionPolicy.RUNTIME)\
   Определяет, что аннотация сохраняется во время выполнения программы и доступна через механизм рефлексии.

   - public @interface Invoke\
   Объявляет собственную аннотацию без параметров.

Результат выполнения задания:

```java
Запуск обработки Invoke

Method three invoked
Method one invoked
```

&nbsp;

> Задание 2 – (аннотация @Default)

Разработайте аннотацию @Default, со следующими характеристиками:
• Целью может быть ТИП или ПОЛЕ
• Доступна во время исполнения программы
• Имеет обязательное свойство value типа Class
Проаннотируйте какой-либо класс данной аннотацией, указав тип по умолчанию.
Напишите обработчик, который выводит имя указанного класса по умолчанию.
___

В ходе выполнения данного задания были разработаны классы DefaultProcessor и TestClass2, аннотация Default.

### класс DefaultProcessor
В класс входит один метод

*Метод*:
public static void process(Class<?> clas):

   - Принимает объект типа Class<?>, представляющий метаинформацию о анализируемом классе.
   - Проверяет наличие аннотации @Default:
      + сначала у самого класса (цель TYPE),
      + затем у его полей (цель FIELD).
   - Если аннотация присутствует:
      + Получает её экземпляр через метод getAnnotation().
      + Извлекает значение параметра value(), которое содержит тип по умолчанию.
      + Выводит в консоль имя указанного класса по умолчанию.
   - Если аннотация отсутствует как на классе, так и на его полях — выводится сообщение о её отсутствии.

### Класс TestClass2 - это тестовый класс, аннотированный пользовательской аннотацией @Default.
   - Аннотация @Default(String.class) указывает, что типом по умолчанию для данного класса является String.
   - В параметре аннотации передаётся объект типа Class — в данном случае String.class.
+ В классе также присутствует поле:
   - Поле numberField аннотировано @Default(Integer.class), что означает, что для данного поля типом по умолчанию является Integer.
+ Поле name не содержит аннотации и используется для демонстрации того, что обработчик корректно игнорирует элементы без @Default.

### Аннотация Default
@Default — это пользовательская аннотация, предназначенная для указания класса по умолчанию для помеченного типа или поля.

Описание:

   - @Target({ElementType.TYPE, ElementType.FIELD})\
   Указывает, что аннотацию можно применять к классам (типам) и полям.

   - @Retention(RetentionPolicy.RUNTIME)\
   Определяет, что аннотация сохраняется во время выполнения программы и доступна через механизм рефлексии.

   - public @interface Default\
   Объявляет собственную аннотацию с одним параметром Class<?> value(), который позволяет указать класс по умолчанию.

Результат выполнения задания:

```java
Запуск обработки Default

Тип по умолчанию: double
```

&nbsp;

> Задание 3 – (аннотация @ToString)

Разработайте аннотацию @ToString, со следующими характеристиками:
• Целью может быть ТИП или ПОЛЕ
• Доступна во время исполнения программы
• Имеет необязательное свойство valuec двумя вариантами значений: YES или NO
• Значение свойства по умолчанию: YES
Проаннотируйте класс аннотацией @ToString, а одно из полей – с @ToString(Mode.NO).
Создайте метод, который формирует строковое представление объекта, учитывая только те поля, 
где @ToString имеет значение YES.
___

В ходе выполнения данного задания были разработаны классы ToStringProcessor и Person, аннотация ToString, enum Mode.

### класс ToStringProcessor
В класс входит один метод

*Метод*:
public static String buildString(Object obj):
   - Принимает объект любого класса.
   - Получает метаинформацию о классе объекта через obj.getClass().
   - Проверяет, есть ли на классе аннотация @ToString и что её параметр value не равен Mode.NO.
      + Если аннотация отсутствует или value == Mode.NO, возвращает строку "Аннотация @ToString отсутствует".
   - Создаёт StringBuilder для формирования итоговой строки.
   - Получает все поля класса через getDeclaredFields().
   - Для каждого поля:
      + Делаем поле доступным через setAccessible(true).
      + Определяет режим (Mode) — по умолчанию Mode.YES.
      + Если поле аннотировано @ToString, получает значение параметра value().
      + Если режим равен Mode.YES, добавляет в строку имя поля и его значение (field.get(obj)).
   - Удаляет лишнюю запятую в конце строки, если она есть.
   - Возвращает сформированное строковое представление объекта в виде:\
   ИмяКласса { поле1=значение1, поле2=значение2, ... }.

### Класс Person предназначен для демонстрации работы аннотации @ToString.
Описание:
   - Класс аннотирован @ToString, что позволяет ToStringProcessor формировать его строковое представление автоматически.
   - Содержит три поля:
      + private String name — имя человека, включается в строковое представление.
      + private int age — возраст человека, включается в строковое представление.
      + private String password — пароль, помечен аннотацией @ToString(Mode.NO), поэтому не включается в строку.

### Аннотация ToString
@ToString — это пользовательская аннотация, предназначенная для пометки классов и полей, которые должны включаться в строковое представление объектов.

Описание:
   - @Target({ElementType.TYPE, ElementType.FIELD})\
   Указывает, что аннотацию можно применять к классам (типам) и полям.

   - @Retention(RetentionPolicy.RUNTIME)\
   Определяет, что аннотация сохраняется во время выполнения программы и доступна через механизм рефлексии.

   - public @interface ToString\
   Объявляет собственную аннотацию с одним параметром value() типа Mode.\
   По умолчанию value() равен Mode.YES, что означает включение класса или поля в строковое представление.

### Перечисление Mode — это перечисление, используемое вместе с аннотацией @ToString для управления включением классов и полей в строковое представление объектов.
Содержит два значения:
   + YES — класс или поле включается в строковое представление.
   + NO — класс или поле исключается из строкового представления.

Результат выполнения задания:

```java
Запуск обработки ToString

Person { name=Arthur, age=25 }
```

&nbsp;

> Задание 4 – (аннотация @Validate)

Разработайте аннотацию @Validate, со следующими характеристиками:
• Целью может быть ТИП или АННОТАЦИЯ
• Доступна во время исполнения программы
• Имеет обязательное свойство value, типа Class[]
Проаннотируйте класс аннотацией @Validate, передав список типов для проверки.
Реализуйте обработчик, который выводит, какие классы указаны в аннотации.
___

В ходе выполнения данного задания были разработаны классы ValidateProcessor и TestClass3, аннотация Validate.

### класс ValidateProcessor
В класс входит один метод

*Метод*:
public static void process(Class<?> clas):
   - Принимает объект типа Class<?> — метаинформацию о классе.
   - Проверяет наличие аннотации @Validate с помощью isAnnotationPresent().
      + Если аннотация отсутствует — выводит сообщение "Аннотация @Validate отсутствует" и завершает работу метода.
   - Если аннотация присутствует:
      + Получает её экземпляр через getAnnotation().
      + Извлекает массив классов через value().
      + Выводит в консоль список всех классов, указанных в аннотации.

### Класс TestClass3 предназначен для демонстрации работы аннотации @Validate.
Описание:
   - Класс аннотирован @Validate с указанием массива классов:
      + String.class
      + Integer.class
      + Double.class
   - Аннотация позволяет ValidateProcessor определить, какие классы связаны с этим объектом.

### Аннотация Validate
@Validate — это пользовательская аннотация, предназначенная для указания одного или нескольких классов, связанных с аннотированным типом.

Описание:
   - @Target({ElementType.TYPE, ElementType.ANNOTATION_TYPE})\
   Указывает, что аннотацию можно применять к классам и к другим аннотациям.

   - @Retention(RetentionPolicy.RUNTIME)\
   Определяет, что аннотация сохраняется во время выполнения программы и доступна через механизм рефлексии.

   - public @interface Validate\
   Объявляет собственную аннотацию с параметром value(), который представляет массив классов (Class<?>[]).
   Позволяет указать один или несколько классов, связанных с аннотированным объектом.

Результат выполнения задания:

```java
Запуск обработки Validate

Классы, указанные в @Validate: 
 - java.lang.String
 - java.lang.Integer
 - java.lang.Double
```

&nbsp;

> Задание 5 – (аннотация @Two)

Разработайте аннотацию @Two, со следующими характеристиками:
• Целью может быть ТИП
• Доступна во время исполнения программы
• Имеет два обязательных свойства: first типа String и second типа int
Проаннотируйте какой-либо класс аннотацией @Two, передав строковое и числовое значения.
Реализуйте обработчик, который считывает и выводит значения этих свойств.
___

В ходе выполнения данного задания были разработаны классы TwoProcessor и TestClass4, аннотация Two.

### TwoProcessor
В класс входит один метод

*Метод*:
public static void process(Class<?> clas):

   - Принимает объект типа Class<?> — метаинформацию о классе.
   - Проверяет наличие аннотации @Two с помощью isAnnotationPresent().
      + Если аннотация отсутствует — выводит сообщение "Аннотация @Two отсутствует" и завершает работу метода.
   - Если аннотация присутствует:
      + Получает её экземпляр через getAnnotation().
      + Извлекает значения параметров: first() — строковое значение и second() — целочисленное значение.
      + Выводит в консоль значения этих параметров.

### Класс TestClass4 предназначен для демонстрации работы аннотации @Two.
Описание:
   - Класс аннотирован @Two с указанием параметров:
      + first = "Hello" — строковое значение.
      + second = 15 — целочисленное значение.
   - Аннотация позволяет TwoProcessor определить и вывести значения этих параметров для класса.

### Аннотация Two
@Two — это пользовательская аннотация, предназначенная для задания двух параметров у класса: строкового и целочисленного.

Описание:

   - @Target(ElementType.TYPE)\
   Указывает, что аннотацию можно применять только к классам (типам).

   - @Retention(RetentionPolicy.RUNTIME)\
   Определяет, что аннотация сохраняется во время выполнения программы и доступна через механизм рефлексии.

   - public @interface Two\
   Объявляет аннотацию с двумя параметрами:
      + String first() — строковое значение.
      + int second() — целочисленное значение.

Результат выполнения задания:

```java
Запуск обработки Two

Значения аннотации @Two: 
first = Hello
second = 15
```

&nbsp;

> Задание 6 – (аннотация @Cache)

Разработайте аннотацию @Cache, со следующими характеристиками:
• Целью может быть ТИП
• Доступна во время исполнения программы
• Имеет необязательное свойство value, типа String[]
• Значение свойства по умолчанию: пустой массив
Проаннотируйте класс аннотацией @Cache, указав несколько кешируемых областей.
Создайте обработчик, который выводит список всех кешируемых областей или сообщение, что 
список пуст.
___

В ходе выполнения данного задания были разработаны классы CacheProcessor, TestClass5 и TestClass6, аннотация Cache.

### CacheProcessor
В класс входит один метод

*Метод*:
public static void process(Class<?> clas):

   - Принимает объект типа Class<?> — метаинформацию о классе.
   - Проверяет наличие аннотации @Cache с помощью isAnnotationPresent().
      + Если аннотация отсутствует — выводит сообщение "Аннотация @Cache отсутствует" и завершает работу метода.
   - Если аннотация присутствует:
      + Получает её экземпляр через getAnnotation().
      + Извлекает массив строк через value(), представляющий кешируемые области.
      + Если массив пуст — выводит "Список кешируемых областей пуст".
      + Иначе — выводит в консоль все указанные области.

### Класс TestClass5 предназначен для демонстрации работы аннотации @Cache.

Описание:
   - Класс аннотирован @Cache с указанием массива кешируемых областей:
      + "users"
      + "items"
      + "orders"
   - Аннотация позволяет CacheProcessor определить, какие области данных нужно учитывать при кешировании.

### Класс TestClass6 емонстрирует работу аннотации @Cache без указания конкретных кешируемых областей.

Описание:
   - Класс аннотирован @Cache без параметров.
   - Аннотация позволяет CacheProcessor обработать класс, но массив кешируемых областей будет пустым.

### Аннотация Cache
@Cache — это пользовательская аннотация, предназначенная для указания кешируемых областей у класса.

Описание:

   - @Target(ElementType.TYPE)\
   Указывает, что аннотацию можно применять только к классам (типам).

   - @Retention(RetentionPolicy.RUNTIME)\
   Определяет, что аннотация сохраняется во время выполнения программы и доступна через механизм рефлексии.

   - public @interface Cache\
   Объявляет аннотацию с параметром value() типа массив строк (String[]).
      + Позволяет указать одну или несколько областей для кеширования.
      + По умолчанию массив пустой (default {}), что позволяет использовать аннотацию без параметров.

Результат выполнения задания:

```java
Запуск обработки Cache

TestClass5:
Кешируемые области:
 - users
 - items
 - orders

TestClass6:
Список кешируемых областей пуст
```
