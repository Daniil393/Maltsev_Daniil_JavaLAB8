# Лабораторная работа 4. ИКНТ, Мальцев Даниил ИТ18 - группа LAB8.

Лабораторная работа представляет из себя:

## Класс Main - главный класс, который вызывает в себе классы и интерфейсы заданий 1 - 7

## Классы и интерфейсы:

1.1) public class Box

1.2) interface Сравнимое

1.3) public class Person

1.4) public class Book<br><br>

2.1)<br><br>

3.1) public interface Collector

3.2) public interface CollectorFactory

3.3) public class CollectUtil

3.4) public interface Predicate

3.5) public class Filter

3.6) public class IntArrayWrapper

3.7) public class IntegerWrapper

3.8) public class StringWrapper

3.9) public interface MyFunction

3.10) public class Transformer

3.11) public interface Reducer

3.12) public class ReducerUtil<br><br>

Вспомогательный класс:
public class InputHelper - проверка ввода пользователя

---
Рассмотрим каждый класс индивидуально

## Класс Main

Класс Main в общей структуре состоит из цикла while, который прокручивает реализацию всех заданий, выбор самих заданий осуществляется с помощью конструкции switсh-case - пользователь выбирает какое задание он хочет просмотреть и в зависимости от его выбора реализуется соответствующий case

```java
System.out.println("\n=== Лабораторная работа 4 ===");
            System.out.println("1 - Обобщенная коробка");
            System.out.println("2 - Сравнимое");
            System.out.println("3 - Поиск максимума");
            System.out.println("4 - Обобщенные методы, автовывод типа. Функция");
            System.out.println("5 - Обобщенные методы, автовывод типа. Фильтр");
            System.out.println("6 - Обобщенные методы, автовывод типа. Сокращение");
            System.out.println("7 - Обобщенные методы, автовывод типа. Коллекционирование");
            System.out.println("0 - Выход");
            System.out.print("Ваш выбор: ");
```

> Задание 1.1 (1 - Обобщенная коробка)
>
> В данном задании необходимо создать сущность Коробка, которая обладает следующими характеристиками:
> - Может хранить один произвольный объект в один момент времени.
> - Объект можно получить и разместить на хранение в любой момент времени.
> - Если объект забирают из коробки – ссылку на этот объект необходимо обнулить.
> - Если объект кладут в коробку, но она не пуста – необходимо выкинуть исключение.
> - Имеет метод проверки на заполненность.
> - Методы класса должны работать с тем типом данных, который был указан во время 
> создания объекта.
>
> Далее создать коробку которая может хранить целочисленное значение, разместить туда число 3. 
> Передать Коробку в какой-либо метод, извлечь значение, и вывести его на экран.

В ходе выполнения данного задания был создан case 1, в котором вызывался класс Box.

Case 1:

1. Создаётся новый объект Box<Integer> intBox - пустую обобщённую коробку, готовую принимать данные.
2. Запускается цикл меню, позволяющий пользователю по шагам протестировать функциональность класса Box.
3. Предлагаемые действия: поместить число в коробку, извлечь его, просмотр содержимого коробки, проверить заполненость и очистить коробку.
4. При выборе пункта «Поместить число в коробку» запрашивается у пользователя целое значение и вызывает метод put().
5. При выборе пункта «Извлечь число из коробки» выполняется метод get(), забирающий содержимое и очищающий коробку.
6. При выборе пункта «Посмотреть содержимое коробки без извлечения» вызывается метод peek(), демонстрируя текущее значение без удаления.
7. При выборе пункта «Проверить, полна ли коробка» вызывается метод isFull(), который сообщает содержит ли коробка данные.
8. При выборе пункта «Очистить коробку» вызывается метод clear(), который полностью обнуляет внутреннее содержимое.
9. Опция processBox демонстрирует комплексное поведение: выводит текущее состояние и либо извлекает значение, либо уведомляет о пустоте.
10. Любые попытки некорректных операций (например, извлечь из пустой коробки или положить во время занятости) перехватываются блоком try/catch с корректным выводом сообщения об ошибке пользователю.
11. Обрабатывается ответ пользователя и либо показывает результат, либо возвращает в меню.

### 1) Описание класса Box:

*Поля:*
   * content - текущее содержимое коробки (обобщённый тип T).
   * Если значение равно null, коробка считается пустой.

*Конструкторы:*
  * Box() - создаёт пустую коробку без начального содержимого.
  * Box(T content) - создаёт коробку с заранее помещённым объектом.

*Методы:*
   * public void put(T item) - помещает объект в коробку.
   * public T get() - извлекает объект из коробки и очищает её.
   * public boolean isFull() - возвращает true, если в коробке есть объект; false, если она пуста.
   * public T peek() - позволяет посмотреть содержимое без извлечения.
   * public void clear() - полностью очищает коробку, присваивая content = null.
   * public T getContent() - возвращает ссылку на внутренний объект без изменений состояния коробки.
   * Переопределенный toString() - формирует строковое представление.

> Задание 1.3 (2 - Сравнимое)
>
> В данном задании необходимо создать ссылочный тип Сравнимое, гарантирующий наличие по данной ссылке метода со 
> следующими характеристиками:
> - Называется “сравнить”.
> - Принимает объект.
> - Тип принимаемого объекта может быть изменен без изменения самого Сравнимого.
> - Возвращает целое число.

В ходе выполнения данного задания был создан case 2, в котором вызывались классы Person, Book и интерфейс «Сравнимое».

Case 2:

1. Запускается внутреннее меню, позволяющее пользователю выбрать тип объектов для сравнения: людей (Person) или книги (Book).
2. При выборе пункта «Сравнить людей (класс Person)»:
   - Предлагается последовательно ввести имя, возраст и город для первого человека; создаётся объект Person p1.
   - Аналогично запрашиваются данные для второго человека, создаётся Person p2.
   - Оба объекта выводятся на экран в текстовой форме.
   - Вызывается метод p1.сравнить(p2), сравнивающий возраст двух людей.
   - На основе результата сравнения отображается одно из трех сообщений:
      - первый человек моложе;
      - первый человек старше;
      - оба являются ровесниками.
3. При выборе пункта «Сравнить книги (класс Book)»:
   - Пользователь вводит название, год издания, автора и цену первой книги; создаётся объект Book b1.
   - Аналогично вводятся данные второй книги, создаётся Book b2.
   - Обе книги выводятся на экран в виде строк.
   - Метод b1.сравнить(b2) сравнивает цены книг.
   - На основе результата сравнения отображается одно из трех сообщений:
      - первая книга дешевле второй;
      - первая книга дороже второй;
      - обе книги имеют одинаковую цену.
4. Все вводимые параметры проходят обработку методами класса InputHelper, обеспечивая корректное получение строк, чисел и вещественных значений.
5. Структура сравнения основана на пользовательском интерфейсе Сравнимое<T>, который задаёт единый формат метода сравнить() для всех реализующих классов.
6. Обрабатывает ответ пользователя и либо показывает результат, либо возвращает в меню.

### 1) Описание класса Person:

*Поля:*
   * name - имя человека (строка).
   * age - возраст (целое число).
   * city - город проживания (строка).

*Конструктор:*
   * Person(String name, int age, String city) - создаёт объект с заданным именем, возрастом и городом.

*Методы:*
   * Геттеры и сеттеры для всех полей.
   * public int сравнить(Person other) - сравнивает текущий объект с другим человеком по возрасту.
   * Переопределенный toString() - формирует строковое представление.

### 2) Описание класса Book:

*Поля:*
   * title - название книги (строка).
   * year - год издания (целое число).
   * author - автор книги (строка).
   * price - стоимость книги (вещественное число).

*Конструктор:*
   * Book(String title, int year, String author, double price) - создаёт объект с указанным названием, годом издания, автором и ценой.

*Методы:*
   * Геттеры и сеттеры для всех полей.
   * public int сравнить(Book other) - сравнивает две книги по цене.
   * Переопределенный toString() - формирует строковое представление.

### 3) Описание интерфейса Сравнимое<T>:

Интерфейс задаёт правило: любой класс, который его реализует, обязан уметь сравнивать свои объекты между собой.

*Метод:*
   * int сравнить(T other) - метод определяет логику сравнения текущего объекта с другим объектом того же типа.

> Задание 2.2 (3 - Поиск максимума)

> Задание 3.1 (4 - Обобщенные методы, автовывод типа. Функция)
>
> В данном задании необходимо разработать такой метод, который будет принимать список значений типа T, и объект имеющий 
> единственный метод apply. Данный метод надо применить к каждому элементу списка, и вернуть
> новый список значений типа P, при этом типы T и P могут совпадать, а могут не совпадать.
>
> Использовать разработанный метод следующим образом:
> 1. Передайте в метод список со значениями:“qwerty”, “asdfg”, “zx”, а получите список чисел, 
> где каждое число соответствует длине каждой строки.
> 2. Передайте в метод список со значениями: 1,-3,7, а получите список в котором все 
> отрицательные числа стали положительными, а положительные остались без изменений
> 3. Передайте в метод список состоящий из массивов целых чисел, а получите список в 
> котором будут только максимальные значения каждого из исходных массивов

В ходе выполнения данного задания был создан case 4, в котором вызывались классы InputReaders, IntArrayWrapper, IntegerWrapper, StringWrapper, Transformer и интерфейс MyFunction.

Case 4:

1. Запускается внутреннее меню, позволяющее пользователю выбрать тип данных, над которыми будет выполняться преобразование:
   - строки (StringWrapper).
   - целые числа (IntegerWrapper).
   - массивы целых чисел (IntArrayWrapper).
2. При выборе пункта «StringWrapper»:
   - Пользователь вводит произвольное количество строк. Каждая строка оборачивается в объект StringWrapper.
   - Полученный список передаётся в метод Transformer.transform(strings, s -> new IntegerWrapper(s.getValue().length()))
   - Лямбда-функция вычисляет длину каждой строки и помещает её в IntegerWrapper.
   - На экран выводится список длин всех введённых строк.
3. При выборе пункта «IntegerWrapper»:
   - Пользователь вводит произвольное количество целых чисел. Каждый элемент - объект IntegerWrapper.
   - Полученный список передаётся в метод Transformer.transform(ints, iw -> new IntegerWrapper(Math.abs(iw.getValue())))
   - Все отрицательные числа заменяются на положительные.
   - Итоговый список объектов IntegerWrapper выводится пользователю.
4. При выборе пункта «IntArrayWrapper»:
   - Пользователь вводит несколько массивов целых чисел.
   - Список массивов передаётся в метод: Transformer.transform(arrays, aw -> new IntegerWrapper(aw.max()))
   - Для каждого массива берётся максимумaw.max(), результат упаковывается в IntegerWrapper.
   - На экран выводится список максимумов всех введённых массивов.
5. Каждый ввод пользователя проходит обработку с применением методов класса InputReaders
6. В основе всех трёх операций лежит метод transform из класса Transformer, принимающий список объектов и функцию преобразования. Это обеспечивает автовывод типа и демонстрацию принципов работы с функциональными интерфейсами.

### 1) Описание класса InputReaders:

*Методы:*
   * public static List<StringWrapper> readStringList(Scanner sc) - используется для запроса строки с элементами через запятую.
   * public static List<IntegerWrapper> readIntegerList(Scanner sc) - используется для ввода списка целых чисел через запятую.
   * public static List<IntArrayWrapper> readIntArrayList(Scanner sc) - используется для ввода списка массивов int - формата: каждый массив должен быть разделен ";" и элементы массива записаны через пробел. Пример: "1 2 3; 5 7; -1;

### 2) Описание класса IntArrayWrapper:

*Поле:*
   * private int[] array; - целочисленный массив.

*Конструкторы:*
   * public IntArrayWrapper()
   * public IntArrayWrapper(int[] array) - создает объект с указанием массива.

*Методы:*
   * Геттер и сеттер для поля.
   * public int max() - поиск максимума в массиве.
   * public boolean hasPositive() - проверяет все ли элементы массива положительные.
   * Переопределенный toString() - формирует строковое представление.

### 3) Описание класса IntegerWrapper:

*Поле:*
   * private int value; - целочисленное значение.

*Конструкторы:*
   * public IntegerWrapper()
   * public IntegerWrapper(int value) - создает объект с указанием целочисленного значения.

*Методы:*
   * Геттер и сеттер для поля.
   * Переопределенный toString() - формирует строковое представление.

### 4) Описание класса StringWrapper:

*Поле:*
   * private String value; - строковое значение.

*Конструкторы:*
   * public StringWrapper()
   * public StringWrapper(String value) - создает объект с указанием строки.

*Методы:*
   * Геттер и сеттер для поля.
   * Переопределенный toString() - формирует строковое представление.

### 5) Описание класса Transformer:

*Метод:*
   * public static <T, P> List<P> transform(List<T> input, MyFunction<T, P> func) - выполняет обобщённое преобразование списка - по сути, это реализация map.

Принцип работы:
   1. Он принимает список элементов типа T.
   2. Принимает функцию MyFunction<T, P>, которая умеет преобразовывать T в P.
   3. Применяет эту функцию к каждому элементу входного списка.
   4. Складывает результаты в новый список типа P.
   5. Возвращает полученный список.

### 6) Описание интерфейса MyFunction:

функциональный интерфейс, задающий операцию преобразования одного значения типа T в значение типа P.

*Метод:*
   * P apply(T t) - выполняет преобразование входного аргумента t и возвращает результат типа P.

> Задание 3.2 (5 - Обобщенные методы, автовывод типа. Фильтр)
>
> В данном задании необходимо разработать такой метод, который будет принимать список значений типа T и объект имеющий 
> единственный метод test (принимает T и возвращает boolean). Нужно вернуть новый список типа T, из 
> которого удалены все значения не прошедшие проверку условием.
>
> Использовать разработанный метод следующим образом:
> 1. Передать в метод список со значениями: “qwerty”, “asdfg”, “zx”, и отфильтровать все 
> строки имеющие менее трех символов
> 2. Передать в метод список со значениями: 1,-3,7, и отфильтровать все положительные 
> элементы
> 3. Передать в метод список состоящий из массивов целых чисел, а получить список в 
> котором будут только те массивы, в которых нет ни одного положительного элемента

В ходе выполнения данного задания был создан case 5, в котором вызывались классы InputReaders, Filter и интерфейс Predicate.

Case 5:












1. Запускается внутреннее меню, позволяющее пользователю выбрать тип данных, над которыми будет выполняться преобразование:
   - строки (StringWrapper).
   - целые числа (IntegerWrapper).
   - массивы целых чисел (IntArrayWrapper).
2. При выборе пункта «StringWrapper»:
   - Пользователь вводит произвольное количество строк. Каждая строка оборачивается в объект StringWrapper.
   - Полученный список передаётся в метод Transformer.transform(strings, s -> new IntegerWrapper(s.getValue().length()))
   - Лямбда-функция вычисляет длину каждой строки и помещает её в IntegerWrapper.
   - На экран выводится список длин всех введённых строк.
3. При выборе пункта «IntegerWrapper»:
   - Пользователь вводит произвольное количество целых чисел. Каждый элемент - объект IntegerWrapper.
   - Полученный список передаётся в метод Transformer.transform(ints, iw -> new IntegerWrapper(Math.abs(iw.getValue())))
   - Все отрицательные числа заменяются на положительные.
   - Итоговый список объектов IntegerWrapper выводится пользователю.
4. При выборе пункта «IntArrayWrapper»:
   - Пользователь вводит несколько массивов целых чисел.
   - Список массивов передаётся в метод: Transformer.transform(arrays, aw -> new IntegerWrapper(aw.max()))
   - Для каждого массива берётся максимумaw.max(), результат упаковывается в IntegerWrapper.
   - На экран выводится список максимумов всех введённых массивов.
5. Каждый ввод пользователя проходит обработку с применением методов класса InputReaders
6. В основе всех трёх операций лежит метод transform из класса Transformer, принимающий список объектов и функцию преобразования. Это обеспечивает автовывод типа и демонстрацию принципов работы с функциональными интерфейсами.

### 1) Описание класса InputReaders:

*Методы:*
   * public static List<StringWrapper> readStringList(Scanner sc) - используется для запроса строки с элементами через запятую.
   * public static List<IntegerWrapper> readIntegerList(Scanner sc) - используется для ввода списка целых чисел через запятую.
   * public static List<IntArrayWrapper> readIntArrayList(Scanner sc) - используется для ввода списка массивов int - формата: каждый массив должен быть разделен ";" и элементы массива записаны через пробел. Пример: "1 2 3; 5 7; -1;

### 2) Описание класса IntArrayWrapper:

*Поле:*
   * private int[] array; - целочисленный массив.

*Конструкторы:*
   * public IntArrayWrapper()
   * public IntArrayWrapper(int[] array) - создает объект с указанием массива.

*Методы:*
   * Геттер и сеттер для поля.
   * public int max() - поиск максимума в массиве.
   * public boolean hasPositive() - проверяет все ли элементы массива положительные.
   * Переопределенный toString() - формирует строковое представление.

### 3) Описание класса IntegerWrapper:

*Поле:*
   * private int value; - целочисленное значение.

*Конструкторы:*
   * public IntegerWrapper()
   * public IntegerWrapper(int value) - создает объект с указанием целочисленного значения.

*Методы:*
   * Геттер и сеттер для поля.
   * Переопределенный toString() - формирует строковое представление.

### 4) Описание класса StringWrapper:

*Поле:*
   * private String value; - строковое значение.

*Конструкторы:*
   * public StringWrapper()
   * public StringWrapper(String value) - создает объект с указанием строки.

*Методы:*
   * Геттер и сеттер для поля.
   * Переопределенный toString() - формирует строковое представление.

### 5) Описание класса Transformer:

*Метод:*
   * public static <T, P> List<P> transform(List<T> input, MyFunction<T, P> func) - выполняет обобщённое преобразование списка - по сути, это реализация map.

Принцип работы:
   1. Он принимает список элементов типа T.
   2. Принимает функцию MyFunction<T, P>, которая умеет преобразовывать T в P.
   3. Применяет эту функцию к каждому элементу входного списка.
   4. Складывает результаты в новый список типа P.
   5. Возвращает полученный список.

### 6) Описание интерфейса MyFunction:

функциональный интерфейс, задающий операцию преобразования одного значения типа T в значение типа P.

*Метод:*
   * P apply(T t) - выполняет преобразование входного аргумента t и возвращает результат типа P.
