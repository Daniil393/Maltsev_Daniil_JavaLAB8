# Лабораторная работа 4. ИКНТ, Мальцев Даниил ИТ18 - группа LAB8.

Лабораторная работа представляет из себя:

## Класс Main - главный класс, который вызывает в себе классы и интерфейсы заданий 1 - 7

## Классы и интерфейсы:

1.1) public class Box

1.2) interface Сравнимое

1.3) public class Person

1.4) public class Book<br><br>

2.1) public class BoxUtils

3.1) public interface Collector

3.2) public interface CollectorFactory

3.3) public class CollectUtil

3.4) public interface Predicate

3.5) public class Filter

3.6) public class IntArrayWrapper

3.7) public class IntegerWrapper

3.8) public class StringWrapper

3.9) public interface MyFunction

3.10) public class Transformer

3.11) public interface Reducer

3.12) public class ReducerUtil<br><br>

Вспомогательный класс:
public class InputHelper - проверка ввода пользователя

---
Рассмотрим каждый класс индивидуально

## Класс Main

Класс Main в общей структуре состоит из цикла while, который прокручивает реализацию всех заданий, выбор самих заданий осуществляется с помощью конструкции switсh-case - пользователь выбирает какое задание он хочет просмотреть и в зависимости от его выбора реализуется соответствующий case

```java
System.out.println("\n=== Лабораторная работа 4 ===");
            System.out.println("1 - Обобщенная коробка");
            System.out.println("2 - Сравнимое");
            System.out.println("3 - Поиск максимума из коробок");
            System.out.println("4 - Обобщенные методы, автовывод типа. Функция");
            System.out.println("5 - Обобщенные методы, автовывод типа. Фильтр");
            System.out.println("6 - Обобщенные методы, автовывод типа. Сокращение");
            System.out.println("7 - Обобщенные методы, автовывод типа. Коллекционирование");
            System.out.println("0 - Выход");
            System.out.print("Ваш выбор: ");
```

> Задание 1.1 (1 - Обобщенная коробка)
>
> В данном задании необходимо создать сущность Коробка, которая обладает следующими характеристиками:
> - Может хранить один произвольный объект в один момент времени.
> - Объект можно получить и разместить на хранение в любой момент времени.
> - Если объект забирают из коробки – ссылку на этот объект необходимо обнулить.
> - Если объект кладут в коробку, но она не пуста – необходимо выкинуть исключение.
> - Имеет метод проверки на заполненность.
> - Методы класса должны работать с тем типом данных, который был указан во время 
> создания объекта.
>
> Далее создать коробку которая может хранить целочисленное значение, разместить туда число 3. 
> Передать Коробку в какой-либо метод, извлечь значение, и вывести его на экран.

В ходе выполнения данного задания был создан case 1, в котором вызывался класс Box.

Case 1:

1. Создаётся новый объект Box<Integer> intBox - пустую обобщённую коробку, готовую принимать данные.
2. Запускается цикл меню, позволяющий пользователю по шагам протестировать функциональность класса Box.
3. Предлагаемые действия: поместить число в коробку, извлечь его, просмотр содержимого коробки, проверить заполненость и очистить коробку.
4. При выборе пункта «Поместить число в коробку» запрашивается у пользователя целое значение и вызывает метод put().
5. При выборе пункта «Извлечь число из коробки» выполняется метод get(), забирающий содержимое и очищающий коробку.
6. При выборе пункта «Посмотреть содержимое коробки без извлечения» вызывается метод peek(), демонстрируя текущее значение без удаления.
7. При выборе пункта «Проверить, полна ли коробка» вызывается метод isFull(), который сообщает содержит ли коробка данные.
8. При выборе пункта «Очистить коробку» вызывается метод clear(), который полностью обнуляет внутреннее содержимое.
9. Опция processBox демонстрирует комплексное поведение: выводит текущее состояние и либо извлекает значение, либо уведомляет о пустоте.
10. Любые попытки некорректных операций (например, извлечь из пустой коробки или положить во время занятости) перехватываются блоком try/catch с корректным выводом сообщения об ошибке пользователю.
11. Обрабатывается ответ пользователя и либо показывает результат, либо возвращает в меню.

### 1) Описание класса Box:

*Поля:*
   * content - текущее содержимое коробки (обобщённый тип T).
   * Если значение равно null, коробка считается пустой.

*Конструкторы:*
  * Box() - создаёт пустую коробку без начального содержимого.
  * Box(T content) - создаёт коробку с заранее помещённым объектом.

*Методы:*
   * public void put(T item) - помещает объект в коробку.
   * public T get() - извлекает объект из коробки и очищает её.
   * public boolean isFull() - возвращает true, если в коробке есть объект; false, если она пуста.
   * public T peek() - позволяет посмотреть содержимое без извлечения.
   * public void clear() - полностью очищает коробку, присваивая content = null.
   * public T getContent() - возвращает ссылку на внутренний объект без изменений состояния коробки.
   * Переопределенный toString() - формирует строковое представление.

*Пример работы case 1*<br><br>

<img width="501" height="306" alt="image" src="https://github.com/user-attachments/assets/53846fae-362c-4265-9047-b26c38863bfc" />

<img width="524" height="591" alt="image" src="https://github.com/user-attachments/assets/a183f1c1-9a11-49d5-a5fe-92d282c293a9" />

<img width="503" height="320" alt="image" src="https://github.com/user-attachments/assets/0ff7bac9-09b4-4d5b-b4a4-d515e99252b5" />

> Задание 1.3 (2 - Сравнимое)
>
> В данном задании необходимо создать ссылочный тип Сравнимое, гарантирующий наличие по данной ссылке метода со 
> следующими характеристиками:
> - Называется “сравнить”.
> - Принимает объект.
> - Тип принимаемого объекта может быть изменен без изменения самого Сравнимого.
> - Возвращает целое число.

В ходе выполнения данного задания был создан case 2, в котором вызывались классы Person, Book и интерфейс «Сравнимое».

Case 2:

1. Запускается внутреннее меню, позволяющее пользователю выбрать тип объектов для сравнения: людей (Person) или книги (Book).
2. При выборе пункта «Сравнить людей (класс Person)»:
   - Предлагается последовательно ввести имя, возраст и город для первого человека; создаётся объект Person p1.
   - Аналогично запрашиваются данные для второго человека, создаётся Person p2.
   - Оба объекта выводятся на экран в текстовой форме.
   - Вызывается метод p1.сравнить(p2), сравнивающий возраст двух людей.
   - На основе результата сравнения отображается одно из трех сообщений:
      - первый человек моложе;
      - первый человек старше;
      - оба являются ровесниками.
3. При выборе пункта «Сравнить книги (класс Book)»:
   - Пользователь вводит название, год издания, автора и цену первой книги; создаётся объект Book b1.
   - Аналогично вводятся данные второй книги, создаётся Book b2.
   - Обе книги выводятся на экран в виде строк.
   - Метод b1.сравнить(b2) сравнивает цены книг.
   - На основе результата сравнения отображается одно из трех сообщений:
      - первая книга дешевле второй;
      - первая книга дороже второй;
      - обе книги имеют одинаковую цену.
4. Все вводимые параметры проходят обработку методами класса InputHelper, обеспечивая корректное получение строк, чисел и вещественных значений.
5. Структура сравнения основана на пользовательском интерфейсе Сравнимое<T>, который задаёт единый формат метода сравнить() для всех реализующих классов.
6. Обрабатывает ответ пользователя и либо показывает результат, либо возвращает в меню.

### 1) Описание класса Person:

*Поля:*
   * name - имя человека (строка).
   * age - возраст (целое число).
   * city - город проживания (строка).

*Конструктор:*
   * Person(String name, int age, String city) - создаёт объект с заданным именем, возрастом и городом.

*Методы:*
   * Геттеры и сеттеры для всех полей.
   * public int сравнить(Person other) - сравнивает текущий объект с другим человеком по возрасту.
   * Переопределенный toString() - формирует строковое представление.

### 2) Описание класса Book:

*Поля:*
   * title - название книги (строка).
   * year - год издания (целое число).
   * author - автор книги (строка).
   * price - стоимость книги (вещественное число).

*Конструктор:*
   * Book(String title, int year, String author, double price) - создаёт объект с указанным названием, годом издания, автором и ценой.

*Методы:*
   * Геттеры и сеттеры для всех полей.
   * public int сравнить(Book other) - сравнивает две книги по цене.
   * Переопределенный toString() - формирует строковое представление.

### 3) Описание интерфейса Сравнимое<T>:

Интерфейс задаёт правило: любой класс, который его реализует, обязан уметь сравнивать свои объекты между собой.

*Метод:*
   * int сравнить(T other) - метод определяет логику сравнения текущего объекта с другим объектом того же типа.

*Пример работы case 2*<br><br>

<img width="637" height="568" alt="image" src="https://github.com/user-attachments/assets/dd5b387f-5163-446d-b057-8250b4c15de1" />

> Задание 2.2 (3 - Поиск максимума из коробок)
>
> Создайте метод, принимающий набор Коробок и возвращающий максимальное из
> их значений в формате double. Принимаемые методом Коробки могут быть параметризованы
> любыми видами чисел.

В ходе выполнения данного задания был создан case 3, в котором вызывались классы BoxUtils и Box.

Case 3:

1. Запускается внутреннее меню, позволяющее пользователю управлять набором коробок с числовыми значениями:
      * добавлять коробки с целыми числами (Box<Integer>),
      * добавлять коробки с вещественными числами (Box<Double>),
      * находить максимальное значение среди всех добавленных коробок.
2. При выборе пункта «Добавить коробку с Integer»:
      * Пользователь вводит целое число.
      * Введённое значение помещается в объект Box<Integer>.
      * Созданная коробка добавляется в общий список коробок.
3. При выборе пункта «Добавить коробку с Double»:
      * Пользователь вводит вещественное число.
      * Введённое значение помещается в объект Box<Double>.
      * Созданная коробка добавляется в общий список коробок.
4. При выборе пункта «Найти максимум»:
      * Список коробок передаётся в метод BoxUtils.findMax.
      * Метод принимает коллекцию коробок, параметризованных любыми числовыми типами (Integer, Double и др.).
      * Для каждой непустой коробки извлекается числовое значение и приводится к типу double.
      * В процессе обхода определяется максимальное значение среди всех коробок.
      * Найденный максимум выводится пользователю в формате double.
5. Если в списке отсутствуют непустые коробки:
      * Метод findMax генерирует исключение IllegalArgumentException,
      * пользователю выводится сообщение об ошибке.

### 1) Описание класса BoxUtils:

*Метод:*
   * public static double findMax(Collection<? extends Box<? extends Number>> boxes):
        - Принимает коллекцию коробок, параметризованных любыми числовыми типами.
        - Обходит все элементы коллекции и анализирует только непустые коробки.
        - Преобразует числовые значения к типу double с помощью метода doubleValue().
        - Определяет и возвращает максимальное значение среди всех коробок.
        - В случае отсутствия непустых коробок генерирует исключение IllegalArgumentException.

### Класс Box описывался ранее в задании 1.1

*Пример работы case 3*<br><br>

<img width="360" height="762" alt="image" src="https://github.com/user-attachments/assets/9936f38e-faa9-4e0c-9feb-257cc4b3d269" />

> Задание 3.1 (4 - Обобщенные методы, автовывод типа. Функция)
>
> В данном задании необходимо разработать такой метод, который будет принимать список значений типа T, и объект имеющий 
> единственный метод apply. Данный метод надо применить к каждому элементу списка, и вернуть
> новый список значений типа P, при этом типы T и P могут совпадать, а могут не совпадать.
>
> Использовать разработанный метод следующим образом:
> 1. Передайте в метод список со значениями:“qwerty”, “asdfg”, “zx”, а получите список чисел, 
> где каждое число соответствует длине каждой строки.
> 2. Передайте в метод список со значениями: 1,-3,7, а получите список в котором все 
> отрицательные числа стали положительными, а положительные остались без изменений
> 3. Передайте в метод список состоящий из массивов целых чисел, а получите список в 
> котором будут только максимальные значения каждого из исходных массивов

В ходе выполнения данного задания был создан case 4, в котором вызывались классы InputReaders, IntArrayWrapper, IntegerWrapper, StringWrapper, Transformer и интерфейс MyFunction.

Case 4:

1. Запускается внутреннее меню, позволяющее пользователю выбрать тип данных, над которыми будет выполняться преобразование:
   - строки (StringWrapper).
   - целые числа (IntegerWrapper).
   - массивы целых чисел (IntArrayWrapper).
2. При выборе пункта «StringWrapper»:
   - Пользователь вводит произвольное количество строк. Каждая строка оборачивается в объект StringWrapper.
   - Полученный список передаётся в метод Transformer.transform(strings, s -> new IntegerWrapper(s.getValue().length()))
   - Лямбда-функция вычисляет длину каждой строки и помещает её в IntegerWrapper.
   - На экран выводится список длин всех введённых строк.
3. При выборе пункта «IntegerWrapper»:
   - Пользователь вводит произвольное количество целых чисел. Каждый элемент - объект IntegerWrapper.
   - Полученный список передаётся в метод Transformer.transform(ints, iw -> new IntegerWrapper(Math.abs(iw.getValue())))
   - Все отрицательные числа заменяются на положительные.
   - Итоговый список объектов IntegerWrapper выводится пользователю.
4. При выборе пункта «IntArrayWrapper»:
   - Пользователь вводит несколько массивов целых чисел.
   - Список массивов передаётся в метод: Transformer.transform(arrays, aw -> new IntegerWrapper(aw.max()))
   - Для каждого массива берётся максимумaw.max(), результат упаковывается в IntegerWrapper.
   - На экран выводится список максимумов всех введённых массивов.
5. Каждый ввод пользователя проходит обработку с применением методов класса InputReaders
6. В основе всех трёх операций лежит метод transform из класса Transformer, принимающий список объектов и функцию преобразования. Это обеспечивает автовывод типа и демонстрацию принципов работы с функциональными интерфейсами.

### 1) Описание класса InputReaders:

*Методы:*
   * public static List<StringWrapper> readStringList(Scanner sc) - используется для запроса строки с элементами через запятую.
   * public static List<IntegerWrapper> readIntegerList(Scanner sc) - используется для ввода списка целых чисел через запятую.
   * public static List<IntArrayWrapper> readIntArrayList(Scanner sc) - используется для ввода списка массивов int - формата: каждый массив должен быть разделен ";" и элементы массива записаны через пробел. Пример: "1 2 3; 5 7; -1;

### 2) Описание класса IntArrayWrapper:

*Поле:*
   * private int[] array; - целочисленный массив.

*Конструкторы:*
   * public IntArrayWrapper()
   * public IntArrayWrapper(int[] array) - создает объект с указанием массива.

*Методы:*
   * Геттер и сеттер для поля.
   * public int max() - поиск максимума в массиве.
   * public boolean hasPositive() - проверяет все ли элементы массива положительные.
   * Переопределенный toString() - формирует строковое представление.

### 3) Описание класса IntegerWrapper:

*Поле:*
   * private int value; - целочисленное значение.

*Конструкторы:*
   * public IntegerWrapper()
   * public IntegerWrapper(int value) - создает объект с указанием целочисленного значения.

*Методы:*
   * Геттер и сеттер для поля.
   * Переопределенный toString() - формирует строковое представление.

### 4) Описание класса StringWrapper:

*Поле:*
   * private String value; - строковое значение.

*Конструкторы:*
   * public StringWrapper()
   * public StringWrapper(String value) - создает объект с указанием строки.

*Методы:*
   * Геттер и сеттер для поля.
   * Переопределенный toString() - формирует строковое представление.

### 5) Описание класса Transformer:

*Метод:*
   * public static <T, P> List<P> transform(List<T> input, MyFunction<T, P> func) - выполняет обобщённое преобразование списка - по сути, это реализация map.

Принцип работы:
   1. Он принимает список элементов типа T.
   2. Принимает функцию MyFunction<T, P>, которая умеет преобразовывать T в P.
   3. Применяет эту функцию к каждому элементу входного списка.
   4. Складывает результаты в новый список типа P.
   5. Возвращает полученный список.

### 6) Описание интерфейса MyFunction:

функциональный интерфейс, задающий операцию преобразования одного значения типа T в значение типа P.

*Метод:*
   * P apply(T t) - выполняет преобразование входного аргумента t и возвращает результат типа P.

*Пример работы case 4*<br><br>

<img width="620" height="321" alt="image" src="https://github.com/user-attachments/assets/9803b788-60b6-4ff8-89ad-6568d05a61f2" />

<img width="676" height="345" alt="image" src="https://github.com/user-attachments/assets/cb781597-ed5b-4e0d-94e8-0ff0afbe7c78" />

> Задание 3.2 (5 - Обобщенные методы, автовывод типа. Фильтр)
>
> В данном задании необходимо разработать такой метод, который будет принимать список значений типа T и объект имеющий 
> единственный метод test (принимает T и возвращает boolean). Нужно вернуть новый список типа T, из 
> которого удалены все значения не прошедшие проверку условием.
>
> Использовать разработанный метод следующим образом:
> 1. Передать в метод список со значениями: “qwerty”, “asdfg”, “zx”, и отфильтровать все 
> строки имеющие менее трех символов
> 2. Передать в метод список со значениями: 1,-3,7, и отфильтровать все положительные 
> элементы
> 3. Передать в метод список состоящий из массивов целых чисел, а получить список в 
> котором будут только те массивы, в которых нет ни одного положительного элемента

В ходе выполнения данного задания был создан case 5, в котором вызывались классы InputReaders, Filter и интерфейс Predicate.

Case 5:

1. Запускается внутреннее меню, позволяющее пользователю выбрать тип фильтрации данных:
   - фильтрация строк по длине;
   - фильтрация целых чисел по значению;
   - фильтрация массивов целых чисел по содержимому.
2. При выборе пункта «Фильтрация по длине»:
   - Пользователь вводит произвольное количество строк, каждая строка оборачивается в объект StringWrapper.
   - Полученный список передаётся в метод Filter.filter(strings, (StringWrapper s) -> s.getValue().length() < 3).
   - Лямбда-выражение проверяет длину строки и пропускает только те элементы, длина которых меньше 3 символов.
   - На экран выводится список строк, прошедших фильтрацию.
3. При выборе пункта «Фильтрация по элементам»:
   - Пользователь вводит произвольное количество целых чисел, каждое число представлено объектом IntegerWrapper.
   - Список передаётся в метод Filter.filter(ints, (IntegerWrapper iw) -> iw.getValue() > 0).
   - Предикат отбирает только положительные значения.
   - Пользователю выводится итоговый список положительных чисел.
4. При выборе пункта «Фильтрация массивов (без положительных элементов)»:
   - Пользователь вводит несколько массивов целых чисел, каждый из которых оборачивается в IntArrayWrapper.
   - Список массивов передаётся в метод Filter.filter(arrays, (IntArrayWrapper a) -> !a.hasPositive()).
   - Для каждого массива выполняется проверка на наличие положительных элементов.
   - В результирующий список попадают только массивы без положительных значений.
   - На экран выводится список массивов с отрицательными элементами.
5. Ввод всех данных осуществляется с использованием методов класса InputReaders.

### 1) Описание класса InputReaders:

*Методы:*
   * public static List<StringWrapper> readStringList(Scanner sc) - используется для запроса строки с элементами через запятую.
   * public static List<IntegerWrapper> readIntegerList(Scanner sc) - используется для ввода списка целых чисел через запятую.
   * public static List<IntArrayWrapper> readIntArrayList(Scanner sc) - используется для ввода списка массивов int - формата: каждый массив должен быть разделен ";" и элементы массива записаны через пробел. Пример: "1 2 3; 5 7; -1;

### 2) Описание класса Filter:

*Метод:*
   * public static <T> List<T> filter(List<T> source, Predicate<T> predicate) - статический метод, выполняющий фильтрацию элементов списка по заданному условию. Метод принимает исходный список и предикат, проверяет каждый элемент и формирует новый список, содержащий только те объекты, для которых условие возвращает true. Исходные данные не изменяются, тип элементов определяется автоматически.

### 3) Описание интерфейса Predicate:

Функциональный интерфейс, задающий логическое условие (проверку) для значения обобщённого типа T. Используется для определения правил отбора элементов при фильтрации коллекций.

*Метод:*
   * boolean test(T value) - выполняет проверку переданного значения value и возвращает true, если объект удовлетворяет заданному условию, и false в противном случае.

*Пример работы case 5*<br><br>

<img width="632" height="282" alt="image" src="https://github.com/user-attachments/assets/e7366bbb-bcae-45d5-ae43-e948be9d6ace" />

<img width="624" height="287" alt="image" src="https://github.com/user-attachments/assets/66a3e55c-7fd1-46d4-be07-e79fa6f026c1" />

> Задание 3.3 (6 - Обобщенные методы, автовывод типа. Сокращение)
> 
> В данном задании необходимо разработать такой метод, который будет принимать список значений типа T
> и способ с помощью которого список значений можно свести к одному значению типа T, которое и возвращается из 
метода.
> 
> Нужно использовать разработанный метод следующим образом:
> 1. Передать в метод список со значениями: “qwerty”, “asdfg”, “zx”, и сформировать одну 
> большую строку, которая состоит из всех строк исходного списка.
> 2. Передать в метод список со значениями: 1,-3,7, и вернуть сумму всех значений исходного 
> списка.
> 3. Имеется список, состоящий из списков целых чисел, получить общеe количество 
> элементов во всех списках.
> Далее необходимо изменить разработанный метод таким образом, чтобы данный метод 
> гарантированно не возвращал null и не выбрасывал ошибок в том случае, если исходный список 
> пуст.

В ходе выполнения данного задания был создан case 6, в котором вызывались классы InputReaders, ReducerUtil, Transformer и интерфейсы MyFunction и Reducer.

Case 6:

1. Запускается внутреннее меню, позволяющее пользователю выбрать тип операции сокращения данных:
   - слияние строк;
   - сумма значений;
   - общеe количество элементов во всех списках.
2. При выборе пункта «Слияние строк»:
   - Пользователь вводит произвольное количество строк, каждая строка представляется объектом StringWrapper.
   - Полученный список передаётся в метод ReducerUtil.reduce(strings, (StringWrapper a, StringWrapper b) -> new StringWrapper(a.getValue() + b.getValue()), new StringWrapper("")).
   - Лямбда-выражение определяет правило объединения двух элементов путём конкатенации строк.
   - В качестве начального значения используется пустая строка.
   - На экран выводится один объект StringWrapper, содержащий результат объединения всех строк.
3. При выборе пункта «Сумма значений»:
   - Пользователь вводит список целых чисел, каждое число оборачивается в IntegerWrapper.
   - Список передаётся в метод ReducerUtil.reduce(ints, (IntegerWrapper a, IntegerWrapper b) -> new IntegerWrapper(a.getValue() + b.getValue()), new IntegerWrapper(0)).
   - Предикат редукции задаёт операцию сложения значений двух объектов.
   - Начальное значение равно нулю.
   - Пользователю выводится итоговая сумма всех элементов списка.
4. При выборе пункта «Общее количество элементов во всех списках»:
   - Пользователь вводит несколько массивов целых чисел, представленных объектами IntArrayWrapper.
   - Сначала выполняется преобразование списка массивов в список их размеров с помощью метода Transformer.transform(arrays, arr -> new IntegerWrapper(arr.getArray().length)).
   - Далее полученный список размеров передаётся в метод ReducerUtil.reduce(sizes, (IntegerWrapper a, IntegerWrapper b) -> new IntegerWrapper(a.getValue() + b.getValue()), new IntegerWrapper(0)).
   - В результате вычисляется общее количество элементов во всех массивах.
   - Итоговое значение выводится на экран.
5. Ввод всех данных осуществляется через методы класса InputReaders.

### 1) Описание класса InputReaders:

*Методы:*
   * public static List<StringWrapper> readStringList(Scanner sc) - используется для запроса строки с элементами через запятую.
   * public static List<IntegerWrapper> readIntegerList(Scanner sc) - используется для ввода списка целых чисел через запятую.
   * public static List<IntArrayWrapper> readIntArrayList(Scanner sc) - используется для ввода списка массивов int - формата: каждый массив должен быть разделен ";" и элементы массива записаны через пробел. Пример: "1 2 3; 5 7; -1;

### 2) Описание класса ReducerUtil:

*Метод:*
   * public static <T> T reduce(List<T> list, Reducer<T> reducer, T identity) - статический метод, выполняющий свёртку списка элементов в одно итоговое значение. Метод последовательно объединяет элементы коллекции по заданному правилу, используя начальное значение, и возвращает результат редукции.

### 3) Описание клааса Transformer:

*Метод:*
   * public static <T, P> List<P> transform(List<T> input, MyFunction<T, P> func) - статический метод, выполняющий преобразование элементов списка из типа T в тип P. Метод последовательно применяет переданную функцию к каждому элементу входного списка, формирует новый список результатов и возвращает его. Исходный список не изменяется, типы входных и выходных данных выводятся автоматически.

### 4) Описание интерфейса MyFunction:

Функциональный интерфейс, задающий операцию преобразования значения одного типа в значение другого типа.

*Метод:*
   * P apply(T t) - принимает аргумент типа T, выполняет преобразование и возвращает результат типа P.

### 5) Описание интерфейса Reducer:

Функциональный интерфейс, задающий операцию объединения двух значений одного типа в одно результирующее значение.

*Метод:*
   * T apply(T a, T b) - принимает два значения типа T, объединяет их по заданному правилу и возвращает результат того же типа.

*Пример работы case 6*<br><br>

<img width="636" height="295" alt="image" src="https://github.com/user-attachments/assets/69b8eb63-be78-4f5a-9f3e-021b6b7755d3" />

<img width="635" height="298" alt="image" src="https://github.com/user-attachments/assets/258619ae-58ac-4da4-be94-9594f5b0eb31" />

> Задание 3.4 (7 - Обобщенные методы, автовывод типа. Коллекционирование)
>
> В данном задании необходимо разработать такой метод, который будет возвращать коллекцию типа P со значениями типа T. 
>
> Данный метод будет принимать:
> 1. Список исходных значений
> 2. Способ создания результирующей коллекции
> 3. Способ передачи значений исходного списка в результирующую коллекцию.
>
> Использовать разработанный метод следующим образом:
> 1. Передать в метод список со значениями: 1,-3,7, и вернуть их разбитыми на два 
> подсписка, в одном из которых будут только положительные числа, а в другом только 
> отрицательные.
> 2. Передать в метод список со значениями: “qwerty”, “asdfg”, “zx”, “qw” и вернуть их 
> разбитыми на подсписки таким образом, чтобы в любом подсписке были строки только 
> одинаковой длины
> 3. Передать в метод список со значениями: “qwerty”, “asdfg”, “qwerty”, “qw” и вернуть набор 
> такого вида, который не может содержать одинаковые объекты.

В ходе выполнения данного задания был создан case 7, в котором вызывались классы InputReaders, CollectUtil и интерфейсы Collector и CollectorFactory.

Case 7:

1. Запускается внутреннее меню, позволяющее пользователю выбрать сценарий коллекционирования данных:
   - разбиение списка чисел на положительные и отрицательные;
   - разбиение списка строк на подсписки строк с одинаковой длиной;
   - разбиение списка строк на подсписки с уникальными строками.
2. При выборе пункта «Разбиение списка чисел на положительные и отрицательные»:
   - Пользователь вводит список целых чисел, каждый элемент представлен объектом IntegerWrapper.
   - Список передаётся в метод CollectUtil.collect(ints, factory, adder).
   - CollectorFactory создаёт результирующую коллекцию в виде списка подсписков:
      * первый подсписок — положительные числа;
      * второй — отрицательные;
      * третий — нулевые значения.
   - Collector определяет правило распределения элементов по подспискам в зависимости от значения числа.
   - На экран выводится структура, содержащая все сформированные подсписки.
3. При выборе пункта «Разбиение списка строк на подсписки строк с одинаковой длиной»:
   - Пользователь вводит произвольное количество строк, каждая строка оборачивается в StringWrapper.
   - Метод CollectUtil.collect используется для группировки строк.
   - В качестве результирующей коллекции создаётся Map<Integer, List<StringWrapper>> groups, где:
      * ключ - длина строки;
      * значение - список строк соответствующей длины.
   - Логика добавления элементов реализована через лямбда-выражение с использованием computeIfAbsent.
   - Итоговая карта групп выводится пользователю.

*computeIfAbsent - это метод Map, который упрощает добавление элементов в карту, когда ключа ещё нет.*

4. При выборе пункта «Разбиение списка строк на подсписки с уникальными строками»:
   - Пользователь вводит список строк, представленных объектами StringWrapper.
   - Коллекционирование выполняется в структуру Set<StringWrapper> unique.
   - Для создания коллекции используется ссылка на конструктор HashSet::new.
   - Добавление элементов осуществляется через ссылку на метод Set::add.
   - В результате формируется множество уникальных строк, которое выводится на экран.
5. Ввод всех данных выполняется через методы класса InputReaders.

### 1) Описание класса InputReaders:

*Методы:*
   * public static List<StringWrapper> readStringList(Scanner sc) - используется для запроса строки с элементами через запятую.
   * public static List<IntegerWrapper> readIntegerList(Scanner sc) - используется для ввода списка целых чисел через запятую.
   * public static List<IntArrayWrapper> readIntArrayList(Scanner sc) - используется для ввода списка массивов int - формата: каждый массив должен быть разделен ";" и элементы массива записаны через пробел. Пример: "1 2 3; 5 7; -1;

### 2) Описание класса CollectUtil:

*Метод:*
   * collect(List<T> source, CollectorFactory<P> factory, Collector<P, T> adder) - статический метод, выполняющий коллекционирование элементов списка в произвольную структуру данных. Метод принимает:
   - source - исходный список элементов типа T;
   - factory - фабрику CollectorFactory<P> для создания результирующей коллекции типа P;
   - adder - объект Collector<P, T>, определяющий, как каждый элемент добавляется в коллекцию.

Метод создаёт результирующую коллекцию через фабрику, последовательно перебирает все элементы исходного списка и добавляет их в коллекцию с помощью adder. В конце возвращает полностью собранную коллекцию типа P.

### 3) Описание интерфейса Collector:

Функциональный интерфейс, определяющий способ добавления элементов в коллекцию.

*Метод:*
   * void add(P collection, T value) - принимает коллекцию типа P и элемент типа T, добавляет элемент в коллекцию согласно заданной логике.

### 4) Описание интерфейса CollectorFactory:

Функциональный интерфейс, задающий фабрику для создания новой коллекции. Используется для генерации пустой результирующей структуры перед началом коллекционирования.

*Метод:*
   * P create() - создаёт и возвращает новый объект коллекции типа P.

*Пример работы case 7*<br><br>

<img width="685" height="290" alt="image" src="https://github.com/user-attachments/assets/6d934289-8568-4996-9888-02ae570d085e" />

<img width="685" height="289" alt="image" src="https://github.com/user-attachments/assets/b6b08058-a058-4cef-a761-62b2bc1cc2ad" />
